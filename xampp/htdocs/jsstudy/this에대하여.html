<!DOCTYPE html>
<meta charset="UTF-8">
<body>
    <button id="jungsu">Button</button>
</body>
<script>
    // call, apply 둘 중 1개와 bind를 꼭 기억하자
    const mJungsu = document.querySelector('#jungsu');

    var josh = {
        name : "박정수",
        exp : "장난"
    }

    function fCheck(pName){
        alert(pName + "fCheck 호출" + this.name + this.exp);
    }

    // 이런 경우에 바인딩을 사용하면 좋음 특히 유지보수에 이런 게 필요한 상황을 만나면 미쳐버린다.
    // bind 모르면 소스 전체 형식을 고쳐야한다.
    // bind 사용법 자체는 call과 똑같다. 동작이 다르다.
    // bind는 내부적으로 새로운 함수를 만들어서 해당함수의 포인터(함수이름)만 리턴해준다.
    mJungsu.addEventListener("click", fCheck.bind(josh, "바인드를 붙여보자"));  // bind 방법
    // mJungsu.addEventListener("click", fCheck("매개변수"));  // ()붙이는 순간 그냥 호출이 된다
    // mJungsu.addEventListener("click", fCheck("매개변수"));  // 이렇게 보내면 매개변수 전달 + 바로 실행된다 -> 즉 바인딩 사용해야함


    // this(이것)
    // js를 함수기반 언어인 듯 보이지만, 실제는 객체 지향 언어

    /* 
    function fthis(pArg, pArg2){   // 함수 선언 -> window 객체의 메서드 선언
        console.log("this", this, "매개변수", pArg, pArg2); // window
        // this가 맥락(context)에 따라 달라진다.
        // js개발자들이 못쓰겠다고 함..
        // ㄴ this를 직접 제어할 수 있게, call, apply, bind  *** 를 만들어준다
    }

    var josh = {
        name : "박정수",
        exp : "장난"
    }

    fthis.call(document, "ㅇㅇㅇ", "ㄴㄴㄴ");
    fthis.apply(josh, ["ㅇㅇㅇ", "ㄴㄴㄴ"]);    // call 하고 똑같은데, 매개변수들을 무조건 배열에 넣어주면 된다
    // josh.merong();

    josh.merong = fthis;   // 참조
    */

    
    /* 
    window.fthis();

    var ggg = "테스트"; // 변수선언
    alert(window.ggg);
    */
</script>